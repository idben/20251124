<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>變數的宣告</title>
</head>

<body>

    <script>
        var money; // var 宣告的變數會提升到最上面進行宣告
        console.log(money);
        // var money = 10000;
        money = 10000;


        var aaa = 100;
        let aaa1 = 100;
        const aaa2 = 100;
        // console.log(window); // var 宣告的變數會長在 window 物件下, 超級全域變數
        // let const 就是為了解決這問題而設計

        aaa = 200;
        console.log(aaa);
        aaa1 = 200;
        console.log(aaa1);
        // aaa2 = 200; // const 宣告的變數, 不能重新用等號給值

        var aaa = 300;
        console.log(aaa); // var 宣告的變數, 竟然可以重新宣告, 不敢相信!!!
        // let const 就是為了解決這問題而設計
        // let aaa1 = 300;
        // const aaa2 = 300;

        var bbb;
        bbb = 100;
        console.log(bbb);
        let bbb1;
        bbb1 = 100;
        console.log(bbb1);
        // const bbb2; // 只有 const 宣告的變數, 馬上要用等號給值

        c1();
        // console.log(insideC1); // var 是 function scope
        // console.log(insideC2); // const/let 是 block scope

        if (aaa == 300) {
            console.log("------aaa=300----");
            var if1 = 3000;
            let if2 = 3000;
        }
        console.log(if1);
        // console.log(if2);





        // 寫在全域位置的 function 也會提升
        function c1() {
            var aaa = "ABC123"; // 同名變數當中, 優先使用 function 裡宣告的
            console.log("-------c1------");
            console.log(aaa);
            console.log(aaa1);
            console.log(aaa2);
            var insideC1 = 2000;
            let insideC2 = 2000;
        }
    </script>
</body>

</html>